from typing import List, Optional, Tuple, TypeVar

import cv2
import numpy as np
import torch
from skimage import morphology
from skimage.measure import label, regionprops

from rx_connect.core.images.geometry import center_distance, expand_bounding_box

T = TypeVar("T", np.ndarray, torch.Tensor)


def to_three_channels(mask: T) -> T:
    """Converts a single channel mask to a three-channel mask. The resulting mask will have the
    same value for all three channels. This is useful for visualizing the mask on the image.

    Args:
        mask (T): The single channel mask to convert.

    Returns:
        T: The three-channel mask.

    Raises:
        TypeError: If the type of the mask is not supported.
        AssertionError: If the mask is not a single channel mask.
    """
    assert mask.ndim == 2, "Must be a single channel mask"
    if isinstance(mask, torch.Tensor):
        return mask.repeat(3, 1, 1)
    elif isinstance(mask, np.ndarray):
        return np.repeat(mask[..., None], 3, axis=2)
    else:
        raise TypeError("Unsupported type for mask")


def generate_grayscale_mask(image: np.ndarray, thresh: int = 0) -> np.ndarray:
    """Generates a boolean mask for the image."""
    # Convert the RGB image to grayscale
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Create a boolean mask where the grayscale image is greater than threshold
    boolean_mask = gray_image > thresh

    return boolean_mask


def fill_largest_contour(mask: np.ndarray, fill_value: int = 1) -> np.ndarray:
    """Fills the largest contour in the mask with the specified value and set
    anything outside the contour to 0.
    """
    mask = mask.astype(np.uint8).copy()
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    mask = np.zeros_like(mask)

    # Check if there are any contours
    if contours:
        # Sort the contours by area in descending order
        contours = sorted(contours, key=cv2.contourArea, reverse=True)

        # Draw the contours with a specific value
        cv2.drawContours(mask, contours, 0, fill_value, thickness=cv2.FILLED)

    return mask > 0


def refine_mask(
    mask: np.ndarray,
    area_threshold: int = 5000,
    min_size: int = 5000,
    kernel_size: int = 9,
) -> np.ndarray:
    """Refines a mask generated by segmentation models by applying morphological operations.

    Args:
        mask (ndarray): The input mask, should be a 2D array.
        area_threshold (int): The area threshold for filling small holes.
        min_size (int): The minimum size of objects to keep.
        kernel_size (int): The size of the square kernel used in morphological operations.

    Returns:
        ndarray: The refined binary mask with the same shape as the input mask.
    """
    if mask.ndim != 2:
        raise ValueError("Mask must be a 2D array")

    # Convert to binary mask
    mask_binary = mask.astype(bool)

    # Fill small holes
    mask_hole_filled = morphology.remove_small_holes(mask_binary, area_threshold=area_threshold)

    # Remove small objects
    mask_cleaned = morphology.remove_small_objects(mask_hole_filled, min_size=min_size)

    # Create square kernel for morphological operation
    kernel = morphology.square(kernel_size)

    # Apply morphological closing
    mask_refined = morphology.closing(mask_cleaned.astype(np.uint8), kernel)

    return mask_refined.astype(bool)


def separate_pills_and_masks(
    image: np.ndarray, mask: np.ndarray, expand_pixels: Optional[int] = None, num_pills: Optional[int] = None
) -> Tuple[List[np.ndarray], List[np.ndarray]]:
    """Separates individual pills and their corresponding masks from an image and a mask. The pills and masks are
    sorted based on the upper right corner of their bounding boxes.

    Args:
        image (ndarray): The original image as a NumPy array.
        mask (ndarray): The mask as a NumPy array.
        expand_pixels (Optional[int]): Pixels to expand the bounding box by. If None, no expansion is applied.
        num_pills (Optional[int]): Number of pills to return. If None, returns all.

    Returns:
        Tuple[List[np.ndarray], List[np.ndarray]]:
        - List of sorted cropped images for each pill.
        - List of sorted cropped masks for each pill.
    """

    # Helper functions for sorting
    def _upper_right(box: Tuple[int, int, int, int]) -> int:
        return box[0] + box[1]

    height, width = image.shape[:2]

    # Label connected components in the mask
    label_image = label(mask)

    # Store bounding boxes and cropped regions
    bounding_boxes: List[Tuple[int, int, int, int]] = []  # (min_row, min_col, max_row, max_col)
    cropped_pills: List[np.ndarray] = []
    cropped_masks: List[np.ndarray] = []

    for region in regionprops(label_image):
        # Expand bounding box if necessary
        bbox = (
            expand_bounding_box(region.bbox, image_shape=(width, height), expand_pixels=expand_pixels)
            if expand_pixels
            else region.bbox
        )
        min_row, min_col, max_row, max_col = bbox

        bounding_boxes.append((min_row, min_col, max_row, max_col))

        # Crop the original image and mask
        cropped_pill = image[min_row:max_row, min_col:max_col]
        cropped_mask = mask[min_row:max_row, min_col:max_col]

        cropped_pills.append(cropped_pill)
        cropped_masks.append(cropped_mask)

    # Sort by distance from the center of the image
    image_center = (image.shape[0] / 2, image.shape[1] / 2)
    sorted_indices = sorted(
        range(len(bounding_boxes)), key=lambda i: center_distance(bounding_boxes[i], image_center)
    )
    if num_pills is not None:
        sorted_indices = sorted_indices[:num_pills]

    # Filter based on sorted indices
    bounding_boxes = [bounding_boxes[i] for i in sorted_indices]
    cropped_pills = [cropped_pills[i] for i in sorted_indices]
    cropped_masks = [cropped_masks[i] for i in sorted_indices]

    # Sort the bounding boxes and cropped regions
    position_sorted_indices = sorted(
        range(len(bounding_boxes)), key=lambda i: _upper_right(bounding_boxes[i])
    )

    # Filter based on sorted indices
    sorted_pills = [cropped_pills[i] for i in position_sorted_indices]
    sorted_masks = [cropped_masks[i] for i in position_sorted_indices]

    return sorted_pills, sorted_masks
